<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MCQ Quiz</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Geist+Mono:wght@100..900&family=Geist:wght@100..900&display=swap" rel="stylesheet">



  <script>
    // Helper to typeset MathJax in dynamic regions
    function __typesetMath(el){
      try {
        if (window.MathJax && MathJax.typesetPromise) {
          return MathJax.typesetPromise(el ? [el] : undefined).catch(function(){});
        }
      } catch(_) {}
      return Promise.resolve();
    }
    // MathJax configuration for LaTeX rendering
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script','noscript','style','textarea','pre','code'],
        ignoreHtmlClass: 'tex2jax_ignore',
        processHtmlClass: 'tex2jax_process'
      },
      svg: { fontCache: 'global' },
      startup: { typeset: false }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script>
    // Apply saved or system theme early to avoid flash
    (function(){
      try {
        var saved = localStorage.getItem('theme');
        var prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        var theme = saved || (prefersDark ? 'dark' : 'light');
        document.documentElement.setAttribute('data-theme', theme);
      } catch (_) {}
    })();
  </script>
  <style>
  :root {
    --bg: #f8efe3; /* warmer light background */
    --card: #ffffff;
    --text: #0f172a;
    --muted: #64748b;
    --secondary: #e2e8f0;
    --secondary-rgb: 226, 232, 240;
    --border: var(--secondary);
    --primary: #0f172a;
    --primary-foreground: #f8fafc;
    --radius: 8px;
    --shadow: 0 1px 2px rgba(0,0,0,0.06);
    --hover: #f1f5f9;
    --tag-bg: #f8fafc;
    --tag-text: #334155;
    --success: #16a34a;
    --danger: #dc2626;
  }
  :root[data-theme="dark"] {
    --bg: #0c0a09; /* warmer near-black */
    --card: rgba(var(--secondary-rgb), 0.08); /* warm glass base */
    --text: #d1cfc0;
    --muted: #94a3b8;
    --secondary: #fff383;
    --secondary-rgb: 255, 243, 131;
    /* Soften borders in dark mode */
    --border: rgba(var(--secondary-rgb), 0.52);
    --primary: #e2e8f0;
    --primary-foreground: #0b0f14;
    --shadow: none;
    --hover: rgba(var(--secondary-rgb), 0.10);
    --tag-bg: rgba(var(--secondary-rgb), 0.06);
    --tag-text: #cbd5f5;
    --success: #22c55e;
    --danger: #ef4444;
  }
  html, body { height: 100%; }
  body {
    margin: 0;
    background: var(--bg);
    color: var(--text);
    font-family: "Geist", Arial, Helvetica, sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
  .stem { line-height: 1.7; font-weight: 500; }
  .wrap { max-width: 1120px; margin: 0 auto; padding: 32px 24px; }
  header { display: flex; align-items: baseline; justify-content: space-between; margin-bottom: 24px; }
  header h1 { font-size: 22px; font-weight: 600; margin: 0; letter-spacing: 0.2px; }
  header .sub { color: var(--muted); font-size: 14px; }

  .grid { display: grid; grid-template-columns: 1fr 360px; gap: 24px; align-items: start; }
  .card {
    background: rgba(255, 255, 255, 0.61);
    border-radius: 22px;
    box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
    backdrop-filter: blur(17px);
    -webkit-backdrop-filter: blur(17px);
    border: 1px solid rgba(255, 255, 255, 0.57);
  }
  :root[data-theme="dark"] .card {
    /* Glassy tint from secondary color */
    background: rgba(var(--secondary-rgb), 0.12);
    border-radius: 22px;
    box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid var(--border);
  }
  :root[data-theme="dark"] body::before {
    content: "";
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 0;
    background-image:
      repeating-linear-gradient(0deg, rgba(255, 255, 255, 0.025) 0, rgba(255, 255, 255, 0.025) 1px, rgba(0, 0, 0, 0.025) 1px, rgba(0, 0, 0, 0.025) 2px),
      repeating-linear-gradient(90deg, rgba(255, 255, 255, 0.02) 0, rgba(255, 255, 255, 0.02) 1px, rgba(0, 0, 0, 0.02) 1px, rgba(0, 0, 0, 0.02) 2px);
    opacity: 0.18;
    mix-blend-mode: soft-light;
  }
  /* Subtle matte grain overlay (light mode) */
  body::after {
    content: "";
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 0;
    background-image:
      radial-gradient(circle at 20% 15%, rgba(0,0,0,0.045) 1px, transparent 1.2px),
      radial-gradient(circle at 80% 40%, rgba(0,0,0,0.035) 1px, transparent 1.2px),
      radial-gradient(circle at 30% 70%, rgba(0,0,0,0.03) 1px, transparent 1.2px),
      radial-gradient(circle at 60% 85%, rgba(0,0,0,0.04) 1px, transparent 1.2px);
    background-size: 26px 26px, 22px 22px, 28px 28px, 24px 24px;
    mix-blend-mode: multiply;
    opacity: 0.22;
  }
  /* Warmer grain in dark mode using secondary tint */
  :root[data-theme="dark"] body::after {
    background-image:
      radial-gradient(circle at 20% 15%, rgba(var(--secondary-rgb),0.18) 1px, transparent 1.2px),
      radial-gradient(circle at 80% 40%, rgba(var(--secondary-rgb),0.14) 1px, transparent 1.2px),
      radial-gradient(circle at 30% 70%, rgba(var(--secondary-rgb),0.12) 1px, transparent 1.2px),
      radial-gradient(circle at 60% 85%, rgba(var(--secondary-rgb),0.16) 1px, transparent 1.2px);
    background-size: 26px 26px, 22px 22px, 28px 28px, 24px 24px;
    mix-blend-mode: soft-light;
    opacity: 0.18;
  }
  .wrap { position: relative; z-index: 1; }
  .theme-toggle { z-index: 10001; }
  .card .content { padding: 20px 22px; }

  .question {
    border: 2px dotted var(--border);
    border-radius: 18px;
    padding: 14px 14px 18px;
    margin-bottom: 24px;
    background: rgba(255,255,255,0.82);
    backdrop-filter: blur(28px) saturate(165%);
    -webkit-backdrop-filter: blur(28px) saturate(165%);
    box-shadow: 0 10px 30px rgba(15,23,42,0.12);
    transition: border-color .2s, box-shadow .2s, background .2s;
  }
  :root[data-theme="dark"] .question {
    /* Glassy tint from secondary color */
    background: rgba(var(--secondary-rgb), 0.01);
    border-color: var(--border);
    box-shadow: 0 10px 30px rgba(2,6,23,0.45);
  }
  .question.correct { border-color: rgba(22,163,74,0.7); box-shadow: 0 6px 18px rgba(22,163,74,0.24); }
  .question.incorrect { border-color: rgba(220,38,38,0.7); box-shadow: 0 6px 18px rgba(220,38,38,0.22); }
  .question.correct.glow-correct { animation: correctGlow 3s ease-out; }
  @keyframes correctGlow {
    0% { box-shadow: 0 0 0 0 rgba(22,163,74,0); }
    35% { box-shadow: 0 0 20px 6px rgba(22,163,74,0.30); }
    100% { box-shadow: 0 6px 18px rgba(22,163,74,0.24); }
  }
  .question.incorrect.glow-incorrect { animation: incorrectGlow 3s ease-out; }
  @keyframes incorrectGlow {
    0% { box-shadow: 0 0 0 0 rgba(220,38,38,0); }
    35% { box-shadow: 0 0 20px 6px rgba(220,38,38,0.34); }
    100% { box-shadow: 0 6px 18px rgba(220,38,38,0.22); }
  }
  /* Brighter feedback in dark mode */
  :root[data-theme="dark"] .question.correct { border-color: rgba(34,197,94,0.95); box-shadow: 0 8px 22px rgba(34,197,94,0.44); }
  :root[data-theme="dark"] .question.incorrect { border-color: rgba(239,68,68,0.95); box-shadow: 0 8px 22px rgba(239,68,68,0.42); }
  :root[data-theme="dark"] .question.correct.glow-correct { animation: correctGlowDark 3s ease-out; }
  :root[data-theme="dark"] .question.incorrect.glow-incorrect { animation: incorrectGlowDark 3s ease-out; }
  @keyframes correctGlowDark {
    0% { box-shadow: 0 0 0 0 rgba(34,197,94,0); }
    35% { box-shadow: 0 0 26px 8px rgba(34,197,94,0.54); }
    100% { box-shadow: 0 8px 22px rgba(34,197,94,0.44); }
  }
  @keyframes incorrectGlowDark {
    0% { box-shadow: 0 0 0 0 rgba(239,68,68,0); }
    35% { box-shadow: 0 0 26px 8px rgba(239,68,68,0.56); }
    100% { box-shadow: 0 8px 22px rgba(239,68,68,0.42); }
  }
  .question h2 { font-size: 16px; font-weight: 600; margin: 0 0 10px; letter-spacing: 0.2px; }
  .qmeta { color: var(--muted); font-size: 12px; margin-bottom: 12px; }
  .tags { display: flex; flex-wrap: wrap; gap: 6px; margin: 8px 0 6px; }
  .tag { background: var(--tag-bg); border: 1px solid var(--border); border-radius: 999px; padding: 2px 8px; font-size: 11px; color: var(--tag-text); }

  ul.choices { list-style: none; padding: 0; margin: 0; display: grid; gap: 8px; }
  .choice { display: flex; align-items: center; gap: 10px; padding: 10px 12px; border: 1px solid var(--border); border-radius: 14px; transition: border-color .2s, background .2s, box-shadow .2s; background: var(--card); }
  .choice input { accent-color: var(--primary); width: 18px; height: 18px; }
  .choice label { flex: 1; cursor: pointer; }
  /* Selected state (container) */
  .choice:has(input:checked) { background: var(--hover); box-shadow: 0 0 0 2px var(--border); }
  /* Fallback highlight via label if :has() unsupported */
  .choice input:checked + label { font-weight: 700; background: var(--hover); padding: 6px 8px; border-radius: 10px; }
  /* Focus-visible on the radio improves accessibility */
  .choice input:focus-visible + label { outline: 2px solid var(--border); outline-offset: 2px; border-radius: 10px; }
  .choice:hover { border-color: #cbd5e1; background: var(--hover); }
  :root[data-theme="dark"] .choice { background: rgba(var(--secondary-rgb), 0.03); }
  :root[data-theme="dark"] .choice input { accent-color: var(--secondary); }
  :root[data-theme="dark"] .choice:has(input:checked) { background: rgba(var(--secondary-rgb), 0.20); box-shadow: 0 0 0 2px rgba(var(--secondary-rgb), 0.50); }
  :root[data-theme="dark"] .choice input:checked + label { background: rgba(var(--secondary-rgb), 0.20); }
  :root[data-theme="dark"] .choice:hover { background: rgba(var(--secondary-rgb), 0.20); }

  .actions { padding: 16px 22px 22px; display: flex; gap: 8px; }
  .btn { appearance: none; border: 1px solid var(--border); background: transparent; color: var(--text); padding: 10px 14px; border-radius: 14px; font-weight: 600; letter-spacing: 0.2px; cursor: pointer; }
  .btn-primary { background: var(--primary); color: var(--primary-foreground); border-color: var(--primary); }
  .btn-secondary { background: transparent; color: var(--text); }
  .btn-ghost { background: transparent; border-color: var(--border); padding: 6px 10px; border-radius: 12px; font-size: 12px; }
  .btn:focus { outline: 2px solid rgba(15,23,42,0.2); outline-offset: 2px; }
  /* Dark mode buttons and borders use secondary (#fff383) */
  :root[data-theme="dark"] .btn { border-color: var(--secondary); background: var(--secondary); color: #0b0f14; }
  :root[data-theme="dark"] .btn-primary { background: var(--secondary); color: #0b0f14; border-color: var(--secondary); }

  .sidebar { position: sticky; top: 24px; color: var(--secondary); }
  .metric { display: flex; align-items: baseline; justify-content: space-between; color: var(--secondary); margin-bottom: 8px; }
  .metric .label { color: var(--secondary); font-size: 12px; }
  .metric .value { font-weight: 700; font-size: 20px; }
  .pill { display: inline-flex; align-items: center; gap: 6px; padding: 2px 8px; border-radius: 999px; background: var(--tag-bg); color: var(--tag-text); border: 1px solid var(--border); font-size: 11px; }
  .pill-success { background: #dcfce7; color: #166534; border-color: #bbf7d0; }
  .pill-danger { background: #fee2e2; color: #991b1b; border-color: #fecaca; }
  .pill-muted { background: var(--tag-bg); color: var(--muted); }
  :root[data-theme="dark"] .pill-success { background: rgba(34,197,94,0.16); color: #bbf7d0; border-color: rgba(34,197,94,0.32); }
  :root[data-theme="dark"] .pill-danger { background: rgba(239,68,68,0.16); color: #fecaca; border-color: rgba(239,68,68,0.32); }
  .source { color: var(--muted); font-size: 11px; margin-top: 10px; word-break: break-all; }

  #outcomeBox { max-height: 280px; overflow: auto; padding-right: 4px; }
  #outcomeBox { scrollbar-width: thin; scrollbar-color: #cbd5e1 transparent; }
  #outcomeBox::-webkit-scrollbar { width: 8px; height: 8px; }
  #outcomeBox::-webkit-scrollbar-track { background: transparent; border-radius: 10px; }
  #outcomeBox::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; border: 2px solid transparent; background-clip: content-box; }
  #outcomeBox:hover::-webkit-scrollbar-thumb { background: #94a3b8; }

  .theme-toggle {
    position: fixed;
    top: 14px;
    right: 14px;
    z-index: 10000;
    background: var(--card);
    color: var(--text);
    border: 1px solid var(--border);
    border-radius: 999px;
    padding: 8px 10px;
    box-shadow: var(--shadow);
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    font-size: 13px;
  }
  .theme-toggle:focus { outline: 2px solid rgba(15,23,42,0.2); outline-offset: 2px; }
  @media (max-width: 480px) {
    .theme-toggle { padding: 8px; gap: 6px; }
    .theme-toggle .label { display: none; }
  }

  @media (max-width: 920px) {
    .grid { grid-template-columns: 1fr; }
    .sidebar { position: static; }
    #outcomeBox { max-height: 220px; }
  }

  .modal { position: fixed; inset: 0; display: none; z-index: 9999; }
  .modal.show { display: block; }
  .modal .backdrop { position: absolute; inset: 0; background: rgba(2,6,23,0.45); }
  .modal .dialog { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
    width: min(92vw, 560px); max-height: 80vh; background: var(--card); color: var(--text); border-radius: 18px; box-shadow: var(--shadow);
    display: flex; flex-direction: column; overflow: hidden; border: 1px solid var(--border); }
  .modal .head { display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; border-bottom: 1px solid var(--border); }
  .modal .head .title { font-weight: 700; }
  .modal .close { appearance: none; border: 0; background: transparent; font-size: 20px; line-height: 1; padding: 6px 10px; cursor: pointer; color: var(--muted); }
  .modal .body { padding: 12px; overflow: auto; }
  .modal .body { scrollbar-width: thin; scrollbar-color: #cbd5e1 transparent; }
  .modal .body::-webkit-scrollbar { width: 8px; height: 8px; }
  .modal .body::-webkit-scrollbar-track { background: transparent; border-radius: 10px; }
  .modal .body::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; border: 2px solid transparent; background-clip: content-box; }
  .modal .body:hover::-webkit-scrollbar-thumb { background: #94a3b8; }

  .math-scroll {
    display: block;
    max-width: 100%;
    overflow-x: auto;
    overflow-y: hidden;
    -webkit-overflow-scrolling: touch;
    margin: 6px 0;
    padding-bottom: 4px;
  }
  .math-scroll { scrollbar-width: thin; scrollbar-color: #cbd5e1 transparent; }
  .math-scroll::-webkit-scrollbar { height: 8px; }
  .math-scroll::-webkit-scrollbar-track { background: transparent; border-radius: 10px; }
  .math-scroll::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; border: 2px solid transparent; background-clip: content-box; }
  .math-scroll:hover::-webkit-scrollbar-thumb { background: #94a3b8; }
  /* Dim explanation for lower emphasis */
  .explanation { opacity: 0.02; }
  /* Scoreboard (first sidebar card) should be fully visible */
  .sidebar > .card:first-child { opacity: 1; }
  /* Explanation foreground matches button color */
  .explanation,
  .explanation .pill,
  .explanation * { color: var(--secondary) !important; }
  /* Scoreboard: distinct styles per theme for visibility */
  .sidebar > .card:first-child,
  .sidebar > .card:first-child * { color: var(--text) !important; }
  :root[data-theme="dark"] .sidebar > .card:first-child,
  :root[data-theme="dark"] .sidebar > .card:first-child * { color: var(--secondary) !important; }
  /* Borderless look */
  .card,
  .choice,
  .tag,
  .pill,
  .pill-success,
  .pill-danger,
  .btn,
  .btn-ghost,
  .modal .dialog,
  .modal .head,
  .theme-toggle { border: none !important; }
  .modal .head { border-bottom: none !important; }
</style>
</head>
<body>
  <button id="themeToggle" class="theme-toggle" type="button" aria-label="Toggle dark mode" title="Toggle theme">
    <span class="icon" aria-hidden="true">??</span>
    <span class="label">Dark</span>
  </button>
  <div class="wrap">
    <header>
      <h1>MCQ Quiz</h1>
      <div class="sub">{{ total }} questions</div>
    </header>

    <div class="grid">
      <form method="post" action="" id="quizForm" autocomplete="off">
        <div class="content">
          {% csrf_token %}
          {% for q in questions %}
            <section class="question" data-correct="{{ q.answer }}" data-qname="q{{ q.index }}" data-json='{{ q.json|escape }}'>
              <div class="qmeta">Question {{ q.index|add:1 }} of {{ total }}</div>
              <p class="stem">{{ q.text|linebreaksbr }}</p>
              <ul class="choices">
                {% for idx, choice in q.choices %}
                  <li class="choice">
                    <input type="radio" name="q{{ q.index }}" value="{{ idx }}" id="q{{ q.index }}_{{ idx }}" {% if q.selected == idx %}checked{% endif %}>
                    <label for="q{{ q.index }}_{{ idx }}">{{ choice }}</label>
                  </li>
                {% endfor %}
              </ul>
              {% if q.extras %}
  
              {% endif %}
              {% if q.explanation %}
              <div class="explanation" style="display:none; margin-top:10px;">
                <div class="pill pill-danger" style="margin-bottom:6px;">Explanation</div>
                <div>{{ q.explanation }}</div>
              </div>
              {% endif %}
            </section>
          {% endfor %}
        </div>
        <div class="actions">
          <a href="{% url 'reset' %}"><button class="btn btn-secondary" type="button">Reset</button></a>
        </div>
      </form>

      <aside class="sidebar" id="sidebar">
        <div class="card" style="margin-bottom:16px;">
          <div class="content">
            <div class="metric"><span class="label">Score</span><span class="value" id="scoreValue">0 / {{ total }}</span></div>
            <div class="metric"><span class="label">Streak</span><span class="value" id="streakValue">0</span></div>
            <span class="pill" id="longestPill">Longest: 0</span>
          </div>
        </div>
        <div class="card">
          <div class="content">
            <div class="metric"><span class="label">Outcome</span><span class="value" id="outcomeStatus">--</span></div>
            <div id="outcomeBox" style="margin-top:8px;">
              <div class="pill pill-muted" id="outcomePill">Awaiting check...</div>
              <div id="outcomeBody" style="margin-top:10px; color: var(--muted); font-size: 13px;">Select an answer and press Check.</div>
              <div id="outcomeMeta" style="margin-top:12px;"></div>
            </div>
            <div class="source">Data: {{ data_source }}</div>
          </div>
        </div>
      </aside>
    </div>
  </div>

  <script>
    // Theme toggle behavior
    (function(){
      const btn = document.getElementById('themeToggle');
      if (btn) {
        const root = document.documentElement;
        const current = () => (root.getAttribute('data-theme') === 'dark') ? 'dark' : 'light';
        const updateButton = (theme) => {
          const icon = btn.querySelector('.icon');
          const label = btn.querySelector('.label');
          if (theme === 'dark') {
            if (icon) icon.textContent = '??';
            if (label) label.textContent = 'Light';
            btn.setAttribute('aria-label', 'Switch to light mode');
            btn.title = 'Switch to light mode';
          } else {
            if (icon) icon.textContent = '??';
            if (label) label.textContent = 'Dark';
            btn.setAttribute('aria-label', 'Switch to dark mode');
            btn.title = 'Switch to dark mode';
          }
        };
        const setTheme = (theme) => {
          root.setAttribute('data-theme', theme);
          try { localStorage.setItem('theme', theme); } catch(_) {}
          updateButton(theme);
        };
        updateButton(current());
        btn.addEventListener('click', () => setTheme(current()==='dark' ? 'light' : 'dark'));
      }
    })();

    // Per-question outcome panel
    (function(){
      const outcomeStatus = document.getElementById('outcomeStatus');
      const outcomePill = document.getElementById('outcomePill');
      const outcomeBody = document.getElementById('outcomeBody');
      const outcomeMeta = document.getElementById('outcomeMeta');
      const scoreEl = document.getElementById('scoreValue');
      const streakEl = document.getElementById('streakValue');
      const longestEl = document.getElementById('longestPill');
      const questions = Array.from(document.querySelectorAll('section.question'));

      // Wrap wide MathJax outputs in a mini horizontal scroller
      function __wrapWideMath(scopeEl){
        try {
          const root = scopeEl || document;
          const blocks = root.querySelectorAll('mjx-container');
          blocks.forEach((mjx) => {
            // Skip if already handled
            if (mjx.closest('.math-scroll')) return;
            const parent = mjx.parentElement;
            if (!parent) return;
            const mjxRect = mjx.getBoundingClientRect();
            // Choose bounds as the nearest scrolling ancestor or provided scope
            const boundsEl = scopeEl || parent;
            const boundsRect = boundsEl.getBoundingClientRect();
            if (mjxRect.width > Math.max(0, boundsRect.width - 8)) {
              // Use span to avoid invalid block-in-p structure; styled as block
              const wrap = document.createElement('span');
              wrap.className = 'math-scroll';
              parent.insertBefore(wrap, mjx);
              wrap.appendChild(mjx);
            }
          });
        } catch(_) {}
      }

      function setOutcome({title, ok, body, meta}){
        outcomeStatus.textContent = title;
        outcomePill.textContent = ok === true ? 'Right Answer' : (ok === false ? 'Incorrect' : 'Awaiting check');
        outcomePill.classList.remove('pill-success', 'pill-danger', 'pill-muted');
        if (ok === true) {
          outcomePill.classList.add('pill-success');
        } else if (ok === false) {
          outcomePill.classList.add('pill-danger');
        } else {
          outcomePill.classList.add('pill-muted');
        }
        // Use current theme text color for readability in light/dark modes
        try {
          const themeText = getComputedStyle(document.documentElement).getPropertyValue('--text').trim();
          outcomeBody.style.color = themeText || '';
        } catch(_) {
          outcomeBody.style.color = '';
        }
        outcomeBody.innerHTML = body;
        __typesetMath(outcomeBody).then(function(){ __wrapWideMath(outcomeBody); });
        // Render attributes
        if (meta) {
          let html = '<div style="display:grid;gap:6px">';
          for (const [k,v] of Object.entries(meta)) {
            const val = typeof v === 'object' ? JSON.stringify(v) : String(v);
            html += `<div style="display:flex;justify-content:space-between;gap:8px"><span class="label" style="color:var(--muted)">${k}</span><span>${val}</span></div>`;
          }
          html += '</div>';
          outcomeMeta.innerHTML = html;
        } else {
          outcomeMeta.innerHTML = '';
        }
      }

      function recomputeTotals(){
        const answers = questions.map(sec => {
          const correct = parseInt(sec.dataset.correct);
          const qname = sec.dataset.qname;
          const checked = document.querySelector(`input[name="${qname}"]:checked`);
          const val = checked ? parseInt(checked.value) : null;
          return (val !== null && val === correct);
        });
        const total = questions.length;
        const score = answers.filter(Boolean).length;
        let streak = 0; for (let i = answers.length - 1; i >= 0; i--) { if (answers[i]) streak++; else break; }
        let longest = 0, cur = 0; for (const a of answers) { if (a) { cur++; if (cur > longest) longest = cur; } else { cur = 0; } }
        scoreEl.textContent = `${score} / ${total}`;
        streakEl.textContent = `${streak}`;
        longestEl.textContent = `Longest: ${longest}`;
      }

      function onCheck(btn){
        const target = btn.dataset.target;
        const sec = document.querySelector(`section.question[data-qname="${target}"]`);
        if (!sec) return;
        const correct = parseInt(sec.dataset.correct);
        const json = JSON.parse(sec.dataset.json || '{}');
        const selected = document.querySelector(`input[name="${target}"]:checked`);
        if (!selected) {
          setOutcome({title: 'No selection', ok: null, body: 'Please choose an option, then press Check.', meta: null});
          recomputeTotals();
          return;
        }
        const chosenIdx = parseInt(selected.value);
        const ok = chosenIdx === correct;
        const choices = json.choices || [];
        const chosenText = choices[chosenIdx] ?? `Option ${chosenIdx+1}`;
        const correctText = choices[correct] ?? `Option ${correct+1}`;
        const explanation = json.explanation || json.explanations || '';
        const body = ok
          ? `<div><strong>${chosenText}</strong> is correct.</div>`
          : `<div style="margin-bottom:8px;">Your answer: <strong>${chosenText}</strong><br>Correct answer: <strong>${correctText}</strong></div>` + (explanation ? `<div>${explanation}</div>` : '');
        // Build attributes excluding heavy fields
        const meta = {...json};
        delete meta.text; delete meta.choices; delete meta.answer; delete meta.explanation; delete meta.explanations;
        setOutcome({title: `Question ${Number((target||'').replace('q',''))+1}`, ok, body, meta});
        // Add visual state on the question card
        sec.classList.toggle('correct', ok);
        sec.classList.toggle('incorrect', !ok);
        // Trigger a brief green glow (1.5s) when correct
        if (ok) {
          // Retrigger correct animation by removing then re-adding the class
          sec.classList.remove('glow-incorrect');
          sec.classList.remove('glow-correct');
          void sec.offsetWidth; // force reflow to restart animation
          sec.classList.add('glow-correct');
          setTimeout(() => sec.classList.remove('glow-correct'), 4100);
        } else {
          // Retrigger incorrect animation similarly
          sec.classList.remove('glow-correct');
          sec.classList.remove('glow-incorrect');
          void sec.offsetWidth;
          sec.classList.add('glow-incorrect');
          setTimeout(() => sec.classList.remove('glow-incorrect'), 4100);
        }
        // Report mistake once per question to server (Upstash-backed)
        if (!ok && !sec.dataset.reported) {
          try {
            // Capture the actual stem text for mistake payloads
            const stemEl = sec.querySelector('.stem');
            const labels = Array.from(sec.querySelectorAll('ul.choices label'));
            const choicesDom = labels.map(l => l.textContent || '');
            const explDom = (sec.querySelector('.explanation > div:last-child') || {}).innerHTML || explanation || '';
            const payload = {
              text: (stemEl ? (stemEl.textContent || '').trim() : (json.text || '')) || '',
              choices: choicesDom.length ? choicesDom : (json.choices || []),
              answer: correct,
              explanation: explDom,
              extras: json.extras || {},
            };
            fetch('/api/mistake/', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            }).catch(() => {});
            sec.dataset.reported = '1';
          } catch(_) {}
        }
        // On mobile, show explanation in a popup if incorrect
        if (!ok && window.matchMedia('(max-width: 920px)').matches) {
          showExplanationPopup(body);
        }
        recomputeTotals();
      }

      document.querySelectorAll('.check-btn').forEach(btn => {
        btn.addEventListener('click', () => onCheck(btn));
      });
      // Auto-check current question on selection change
      document.getElementById('quizForm').addEventListener('change', (e) => {
        recomputeTotals();
        const t = e.target;
        if (t && t.type === 'radio') {
          const sec = t.closest('section.question');
          if (sec) onCheck({ dataset: { target: sec.dataset.qname } });
        }
      });
      recomputeTotals();

      // Run MathJax over stems/options once loaded, then wrap wide formulas
      const quizForm = document.getElementById('quizForm');
      const runTypeset = () => {
        __typesetMath(quizForm || document).then(function(){ __wrapWideMath(quizForm || document); });
      };
      runTypeset();
      const mjxScript = document.getElementById('MathJax-script');
      if (mjxScript) {
        mjxScript.addEventListener('load', runTypeset);
      }

      // ===== Lightweight popup implementation =====
      function ensurePopup() {
        if (document.getElementById('explainModal')) return document.getElementById('explainModal');
        const host = document.createElement('div');
        host.id = 'explainModal';
        host.className = 'modal';
        host.innerHTML = `
          <div class="backdrop" data-close></div>
          <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="explainTitle">
            <div class="head">
              <div class="title" id="explainTitle">Explanation</div>
              <button class="close" type="button" aria-label="Close" data-close>&times;</button>
            </div>
            <div class="body" id="explainBody"></div>
          </div>`;
        document.body.appendChild(host);
        host.addEventListener('click', (e) => {
          if (e.target && e.target.hasAttribute('data-close')) hideExplanationPopup();
        });
        window.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') hideExplanationPopup();
        });
        return host;
      }
      // Preserve scroll position across popup open/close (mobile Safari safe)
      let __lockedScrollY = 0;
      function showExplanationPopup(html) {
        const modal = ensurePopup();
        const body = modal.querySelector('#explainBody');
        body.innerHTML = html;
        __typesetMath(body).then(function(){ __wrapWideMath(body); });
        modal.classList.add('show');
        // Lock background scroll without losing position
        // Capture current scroll position
        __lockedScrollY = window.scrollY || document.documentElement.scrollTop || 0;
        // Prevent background scroll on the root (helps Android/Chrome)
        document.documentElement.style.overflow = 'hidden';
        // Use fixed-position body lock (works reliably on iOS Safari)
        document.body.style.position = 'fixed';
        document.body.style.top = `-${__lockedScrollY}px`;
        document.body.style.left = '0';
        document.body.style.right = '0';
        document.body.style.width = '100%';
      }
      function hideExplanationPopup() {
        const modal = document.getElementById('explainModal');
        if (modal) modal.classList.remove('show');
        // Restore document flow and exact scroll position
        document.documentElement.style.overflow = '';
        const top = parseInt((document.body.style.top || '0').replace('px',''), 10) || 0;
        document.body.style.position = '';
        document.body.style.top = '';
        document.body.style.left = '';
        document.body.style.right = '';
        document.body.style.width = '';
        // Scroll back to where the user was
        const y = top ? -top : (__lockedScrollY || 0);
        window.scrollTo(0, y);
      }
    })();
  </script>
  <script>
    // Debug: log Upstash/local mistakes info when viewing the Mistakes page
    (function(){
      try {
        var dataSource = ("{{ data_source|default:'' }}" || '').toLowerCase();
        if (dataSource === 'mistakes') {
          console.log('[mistakes] data_source:', dataSource);
          fetch('/api/mistakes_count/')
            .then(r => r.json())
            .then(j => console.log('[mistakes] /api/mistakes_count ->', j))
            .catch(e => console.warn('[mistakes] count fetch error', e));
          fetch('/api/mistakes_dump/?limit=5')
            .then(r => r.json())
            .then(j => console.log('[mistakes] /api/mistakes_dump ->', j))
            .catch(e => console.warn('[mistakes] dump fetch error', e));
        }
      } catch (e) {}
    })();
  </script>
</body>
</html>
